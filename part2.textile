h2. A Gentle Introduction to SQL Using SQLite Part II

Now that we have some dirty data and a few keywords, we can start to write some more interesting queries. In the process, we'll learn a few of the idiosyncracies of SQL.

To get started, click on the SQLite Manager tool in your FireFox toolbar:
!http://github.com/tthibo/SQL-Tutorial/raw/master/tool_menu.jpg!

It should ask you if you want to open the last used database (*test.sql*). Click OK.
If you do not get this option, click on the "Connect Database" icon (!http://github.com/tthibo/SQL-Tutorial/raw/master/connect_db.png!) and browse to the file you saved last time. (If you can't find the file, you can recreate it by following the final step in "Part I":http://github.com/tthibo/SQL-Tutorial#readme of this tutorial.)



h3. Knowing your limitations: using <code>LIMIT</code>

h3. Nothing comes of nothing: using IS NULL

Let's take a look back at our original CREATE statement for the contributors table:
<pre><code>CREATE  TABLE "main"."contributors" ("id" INTEGER PRIMARY KEY  AUTOINCREMENT  NOT NULL , "last_name" VARCHAR, "first_name" VARCHAR, "city" VARCHAR, "state" VARCHAR, "zip" VARCHAR, "amount" INTEGER)</code></pre>
Notice that we defined the <code>id</code> column as <code>NOT NULL</code>, which meant that it was a required field. Because that field is serving as our unique identifier or <code>PRIMARY KEY</code> for the row, it can't be empty. 

The keyword <code>NULL</code> is a special value in SQL. It's a placeholder for an empty field. If a field is <code>NULL</code>, it's really empty. That means it's not 0. It's not an empty string (""). If you're of a philosophical mind, you might call <code>NULL</code> the "nothing that is". If you're of a pragmatic mind, you might just think of it as a placeholder where no value has been entered.

But being nothing (or a placeholder for on empty value) comes with a cost. <code>NULL</code> can't be compared with other data types such as strings. And we can't use normal operators to match it, either. So =, <> and friends don't work with <code>NULL</code>. Don't believe me? Try it out:
<pre><code>SELECT * FROM contributors WHERE last_name = NULL;</code></pre>

Instead, to query for null values, we use the keywords <code>IS NULL</code>:
<pre><code>SELECT * FROM contributors WHERE last_name IS NULL;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/last_name_NULL.png!

<code>NULL</code>'s refusal to respond to normal operators can lead to some unforeseen effects. Take a look at this query, and guess what it should return:
<pre><code>SELECT * FROM contributors WHERE state = 'VA' AND last_name <> 'Lewis';</pre></code> (Remember that <code><></code> means the same thing that <code>!=</code> does: "is not equal.")
There are three contributors from VA in the table, Robert Albrecht, Donald S. Lewis, and someone from Rocky Mount whose name fields are empty. (Yes, the data did come in like this from the FEC.) You can see the list by using "Browse & Search" or by running this query: <code>SELECT * FROM contributors WHERE state = 'VA';</code>.

So, the clause <code>WHERE state = 'VA' AND last_name <> Lewis</code> looks like it's asking for all contributors from Virginia whose last name is not Lewis. And it looks like it  should return both Albrecht and the Rocky Mount contributor. But when we run it (cue "Price Is Right" sad horn sound), we only get Albrecht:
!http://github.com/tthibo/SQL-Tutorial/raw/master/not_lewis.png!

"Curiouser and curiouser," you might say. This makes strict logical sense when we say consider that the <code>NULL</code> data type can't be compared with any other data type, but really it does seem a bit of a pain (even to some of the SQL gurus). The solution is to use <code>IS NULL</code>.  Here's one way to write the query to get the results we intended:
<pre><code>SELECT * FROM contributors WHERE state = 'VA' AND (last_name <> 'Lewis' OR last_name IS NULL);</code></pre>(The parentheses are optional here, but they do help express our intentions.)

And now we get the two expected result rows:
!http://github.com/tthibo/SQL-Tutorial/raw/master/lewis_or_null.png!

h4. IS NOT NULL

The opposite of <code>IS NULL</code> is (drumroll) . . .  <code>IS NOT NULL</code>. And it works pretty much as we'd expect:
<pre><code>SELECT * FROM contributors WHERE state = 'VA' AND last_name IS NOT NULL;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/is_not_null.png!

This negative form is pretty handy for filtering null values from the results set.

h3. Casting a wider net with LIKE

While it's helpful to be able to write queries that look for equality (<code>last_name = 'Smith'</code>) or inequality (<code>last_name != 'Smith'</code>), sometimes you want to do something a little messier, such as looking for everyone whose last name starts with 'T'. Or maybe you want to look for matches to a five-digit ZIP code, but some of your rows use ZIP+4. For these kinds of expressions, you can use the <code>LIKE</code> operator, which will perform a partial match.

To perform a partial match using <code>LIKE</code>, you can use both normal characters and special wildcard characters to construct a pattern. For example, the percent sign (<code>%</code>) will match any sequence of zero or more characters. So to match any zip that begins with 77566, we can use this statement:
<pre><code>SELECT zip FROM contributors WHERE zip LIKE '77566%';</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/zip_LIKE.png!

Notice that it matches both 775661497 and 77566036. It would also match 77566, because the <code>%</code> will match zero characters, too.

The <code>%</code> is probably the most common special character used in pattern matching with <code>LIKE</code>. Another less commonly used pattern matcher is the underscore ("_"), which matches any single character in the string. Say, for example, we wanted to start cleaning our data, and we wanted to remove the middle initials from the <code>first_name</code> field and put them into a new <code>middle_name</code> column. (This sort of thing can get tricky very quickly, but for now we'll trip along happily assuming everything goes smoothly.) As a first step, we want simply to examine all of the rows that appear to contain middle initials in <code>first_name</code>. Here's a query that will get us at least part of the way there:
<pre><code>SELECT * FROM contributors WHERE first_name LIKE '% _.';</code></pre>
Reading patterns like this one may prove a little tricky at first, but in time . . . who am I kidding, it's still pretty tricky, but you can figure it out. Let's break it down:

* The pattern starts with <code>%</code>, which we know means "match any series of zero or more characters," which is pretty much anything. 
* Next we have a space (it's hard to see, but it's between the <code>%</code> and the <code>_</code>). So we're matching anything plus a space.
* Then we have the magic underscore (<code>_</code>), meaning any single character.
* And finally, we have a period (<code>.</code>), which is just a literal period here.

And here's the result:
!http://github.com/tthibo/SQL-Tutorial/raw/master/like_initial.png!

So, in English, the pattern says to match "any series of characters followed by a space, a single character, and a period."
This pattern will match things like "John Q." as well as "1234 5." and "#$%^ !." and " B." and "J. B." It won't, however, 
match the string "J. Quincy" because the period isn't the last character in the field. Neither will it match "Alfred E. " because we've left
a space after the period. 

To also match patterns that contain characters after the period, we would need to add a final <code>%</code> to the pattern:
<pre><code>SELECT * FROM contributors WHERE first_name LIKE '% _.%';</code></pre>

Now we're matching the pattern "any series of zero or more characters, followed by a space, followed by a single character, followed by a period, followed by any series of zero or more characters." (So, our little pattern expresses a pretty complex thought.)

Of course, we could just match any <code>first_name</code> that contains a period, like this:
<pre><code>SELECT * FROM contributors WHERE first_name LIKE '%.%';</code></pre> But then we also get names like "S. Truett," which may or may not be what we intended.

h3. Words Games: Using String Functions (SUBSTR, TRIM, UPPER, LOWER)

Using <code>LIKE</code> for partial matches can be pretty powerful, but as we've seen, patterns aren't exactly beach reading. Another way to do partial matching is to use string functions to manipulate the values. String functions usually take the form of a keyword followed by parentheses, and in the parentheses we pass any arguments for the function: <code>KEYWORD(ARG1, ARG2, ARG3)</code>. Usually the first argument is the string we want to manipulate. Here are the most interesting string functions for our purposes:

h4. SUBSTR()

The <code>SUBSTR()</code> function takes the string we hand it in the parentheses and returns a part of the string we define (ergo, substring). (Note: some database systems use <code>SUBSTRING()</code>, rather than <code>SUBSTR()</code>.)

To determine which part of the string to return, <code>SUBSTR()</code> accepts additional arguments: the starting point of the desired substring (counting characters from the left), and the number of characters to grab from that starting point. The full function call takes this form: <code>SUBSTR(STRING, START_POINT, LENGTH)</code>. The third argument is optional. If we leave it off, <code>SUBSTR()</code> returns all characters from the given starting point to the end of the string.

An example is probably more helpful. So, here is the ZIP query from above rewritten to use a substring match:
<pre><code>SELECT zip FROM contributors WHERE SUBSTR(zip, 1, 5) = '77566';</code></pre>
We're asking for all ZIP codes in the table whose first five characters match '77566'. This query will return the same result set we saw above: 775661497 and 77566036.

Functions can also be used in the <code>SELECT</code> clause of the query, so we can do something like this:
<pre><code>SELECT SUBSTR(zip, 1, 5) FROM contributors;</code></pre>
Now we're getting the five-digit representation of all ZIPs in the table (and dropping the extra four digits from the ZIP+4s)
!http://github.com/tthibo/SQL-Tutorial/raw/master/select_substr.png!

h4. TRIM()

The <code>TRIM()</code> function is most frequently used to trim white space from either side of a string. Often during data entry, strings are accidentally inserted with leading or trailing whitespace. To simulate this case, let's mess up the data even more:
<pre><code>UPDATE contributors SET state = ' GA ' WHERE last_name = 'Cathy';</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/state_ga.png!

So, now Cathy isn't appearing in our list of Georgians. Even worse, we've created a new state:
<pre><code>SELECT DISTINCT state FROM contributors;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/distinct_state_space.png!

We can use <code>TRIM()</code> to clean things up:
<pre><code>UPDATE contributors SET state = TRIM(state);</code></pre>

Notice here that we're not using a <code>WHERE</code> clause on the <code>UPDATE</code> statement. This means that all rows will be updated, which is usually not what you want at all. Consider if we had used <code>SET state = 'GA'</code> in the statement above; we'd now have a table full of Georgians and a mess to clean up. Because we're using a function, rather than a literal string here, we can update everything at once, trimming the white space from the front and end of every state value. The function operates on the value in the <code>state</code> column for each row in turn.

And now we're back to normal:
<pre><code>SELECT DISTINCT state FROM contributors;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/select_distinct_state_normal.png!

The <code>TRIM()</code> function can also be used to strip characters other than spaces from the front and end of a string, although this usage is probably less common. To tell <code>TRIM</code> which characters to remove, pass a second argument which contains all the characters to remove. For example, <code>TRIM(state, '.,')</code> would remove any periods or commas appearing at the beginning or end of the state name (i.e. "GA." would become "GA").

h4. UPPER() and LOWER()

Another common problem in dirty data is inconsistencies in capitalization. For example, let's find all of the contributors from Birmingham, Alabama:
<pre><code>SELECT * FROM contributors WHERE state = 'AL' AND city = 'Birmingham';</code></pre>
Hmm . . . apparently there aren't any.

But then when we check on all contributors from Alabama, we get a different story:
<pre><code>SELECT * FROM contributors WHERE state = 'AL';</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/alabama.png!

So, the problem is that Birmingham isn't properly capitalized. Now, we could do a <code>SELECT</code> using <code>city = 'birmingham'</code>, but then we'd miss any rows that properly capitalize the city name. And what about rows that use ALL CAPS? 

An easy way to get around these issues of case-sensitivity is to use the <code>UPPER</code> or <code>LOWER</code> string functions to standardize capitalization on the values:
<pre><code>SELECT * from contributors WHERE UPPER(city) = 'BIRMINGHAM';</code></pre>

This query will give us the lower-case version, but it will also match "Birmingham" and "BIRMINGHAM" (not to mention "BIRMingham").

Note: by default <code>LIKE</code> is not case-sensitive in SQLite, but that is not true of all database management systems. Also, in other database systems, such as MySQL, the basic equality operator (<code>=</code>) is case insensitive, but that's not true in SQLite, and it isn't true in other systems. When in doubt, it's safer to use <code>LOWER</code> or <code>UPPER</code> to ensure case insensitivity. (Also, some databases use <code>UCASE()</code> and <code>LCASE()</code> rather than <code>UPPER()</code> and <code>LOWER()</code>.)

h3. Pull yourself together: The Concatenate Operator (<code>||</code>)

Sometimes we want to combine values from different columns, either in the <code>WHERE</code> clause or for the results. SQLite uses the concatenation operator (<code>||</code>) to combine strings. You combine both literal strings (in quotation marks) with your values, as well.

Say, for instance, we want a nicely formatted list of cities and states for contributors:
<pre><code>SELECT city || ',' || state FROM contributors ORDER BY state, city;</code></pre>
We insert the comma and space as a literal string concatenated with the values from the city and state columns.
!http://github.com/tthibo/SQL-Tutorial/raw/master/concat_city_state.png!

Note: Some other database management systems, such as MySQL use the <code>CONCAT()</code> function to perform concatenation: <code>SELECT CONCAT('A', 'B', 'C') FROM table_name_;</code> would return "ABC" for each row in the table.

h3. Pick One: Using <code>BETWEEN</code> and <code>IN</code>

Often you'll want to get a value from within a range. The <code>BETWEEN</code> operator can do exactly that. Let's see which of our contributors has given between 500 and 1000 dollars:
<pre><code>SELECT * FROM contributors WHERE amount BETWEEN 500 AND 1000;</pre></code>
!http://github.com/tthibo/SQL-Tutorial/raw/master/between.png!
(Note: this query returns the same result as <code>SELECT * FROM contributors WHERE amount >= 500 AND amount <= 1000;</code>, but it's much more readable.)

At other times, you may need to match values from within a set of choices. This is where the <code>IN</code> operator comes in handy. Let's find all contributors from a few southern states:
<pre><code>SELECT * FROM contributors WHERE state IN ('AL', 'GA', 'FL');</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/in.png!
(Again, you could have used a compound statement with <code>state = 'AL' OR state = 'GA' OR state = 'FL'</code> to achieve the same result, but <code>IN</code> syntax makes things much clearer.

h3. Aggregate Functions: COUNT(), MAX(), MIN(), SUM(), AVG()

Aggregate functions allow us to perform calculations on values across rows. Using them, we can start to do some interesting data analysis. Pass in the column name you want to aggregate as the argument in parentheses.
Here's a quick run through some useful ones:

h4. COUNT()

How many contributors do we have from California?
<pre><code>SELECT COUNT(id) FROM contributors WHERE state = 'CA';<code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/count_ca.png!
	
The <code>COUNT(id)</code> function counts the number of unique ids. We could also have used <code>COUNT(*)</code>, which will count the number of rows. The result will be the same.
<code>COUNT()</code> can also be used with <code>DISTINCT</code> to return the number of distinct instances. For example, how many distinct ZIP Codes are there in the table?
<pre><code>SELECT COUNT(DISTINCT zip)  FROM contributors ;</code></pre>
(Note that the the DISTINCT keyword 

h4. MIN() and MAX()

What is the maximum any of our contributors has given?
<pre><code>SELECT MAX(amount) FROM contributors;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/max_amount.png!

h4. SUM()

What is the total amount of contributions from Georgia?
<pre><code>SELECT SUM(amount) FROM contributors WHERE state = 'GA';</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/sum_ga.png!

h4. AVG()

What is the average amount contributed?
<pre><code>SELECT AVG(amount) FROM contributors;</code></pre>
!http://github.com/tthibo/SQL-Tutorial/raw/master/avg_amt.png!

(Of course, the usual caveats about using averages apply. I heard a nice example recently: "Which major at UNC produces graduates with the highest average salary?" Apparently, it was Geography, Michael Jordan's major. Even if it isn't true, it's a nice illustration of the way outliers can skew averages.)

h3. Subqueries

When doing analysis, we often want to base one query on the results of another query. For example, we used the <code>MAX()</code> function to determine the maximum amount contributed. But what if we want to know 
who actually gave that maximum amount? We could try something like this:
<pre><code>SELECT * FROM contributors WHERE amount = MAX(amount);</code></pre>
But we won't like the results:
!http://github.com/tthibo/SQL-Tutorial/raw/master/alert_aggregate.png!





h3. GROUP BY

The real power o

h3. HAVING


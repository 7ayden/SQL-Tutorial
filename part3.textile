h2. A Gentle Introduction to SQL Using SQLite Part III

h3. Spreading the data around: Data Normalization

All of the queries we've run so far are limited to a single table. If all you ever do is import data from a spreadsheet, then you could always limit your queries to a single table. But most data projects of any depth soon involve multiple database tables. 

Why would you want to separate the data into different tables? Well let's think back for a moment to the description of relational databases from Part I:
* Data is organized into tables (relations) that represent a collection of similar objects (e.g. contributors). 
* The columns of the table represent the attributes that members of the collection share (last name, home address, amount of contribution). 
* Each row in the table represents an individual member of the collection (one contributor). 
* And the values in the row represent the attributes of that individual (Smith, 1228 Laurel St., $250).

So, a table contains a set of similar objects, and the objects all share certain attributes. But we could stretch that definition quite a bit: Contributors all have addresses, but they also have recipients (the candidates who received the contributions). Should we include in our *contributors* table the candidate name, the campaign address and phone number, the office sought, the state in which the candidate is running, etc? What about the candidate's treasurer's name? Committee positions the candidate holds? Previous offices held?

Including all of this loosely related data in a single table takes us pretty far afield of the original relation (Contributor). We would also be storing a lot of redundant data (all of the candidate data would be repeated for each contribution). As a result, it could become difficult to update the data: changing a candidate's address, for example, would require a change to each row containing a contributor to that candidate. In addition, it would become increasingly difficult to spot any data entry errors: each misspelling of a candidate's name would be like adding a new candidate, and it would easier to overlook the error amidst all the repeated data. Finally, all of this redundancy means we're taking up more disk space than needed. (This last isn't as big a concern as it once was when disk space was more expensive, but it can present problems.) 

So, in order to help ensure "data integrity":http://en.wikipedia.org/wiki/Data_integrity, to keep tables logically coherent and to reduce disk usage, most database designers implement some degree of data normalization:http://databases.about.com/od/specificproducts/a/normalization.htm. There are varying degrees of normalization, known as the "normal forms," but for practical purposes the goal is to remove repetition and to keep only clearly related data in the same table. 

So, in the campaign contribution example, we would have at least two tables (a *contributors* table and a *candidates* table).

To get started, let's create a fresh database. Start up Firefox and open the SQLite Manager:
!http://github.com/tthibo/SQL-Tutorial/raw/master/open_sqlite.png!

When asked if you want to open the last database, click "Cancel," so we can create a new database:
!http://github.com/tthibo/SQL-Tutorial/raw/master/sqlite_open_last.png!


Click the New Database icon (!http://github.com/tthibo/SQL-Tutorial/raw/master/new_database.png!) and create a database called *contributors_candidates*.
Save it somewhere you can find it, such as the desktop.

Then execute the following CREATE TABLE statement:
<pre><code>CREATE TABLE "candidates" ("id" INTEGER PRIMARY KEY  NOT NULL , "first_name" VARCHAR NOT NULL , "last_name" VARCHAR NOT NULL , "middle_name" VARCHAR, "party" VARCHAR NOT NULL )</code></pre>

This should all be old hat by now. We're just creating a table for the candidates, including some basic information (name and party), and adding a *PRIMARY KEY*, a unique identifier for each candidate.

Now, let's add some data to that table. Grab the text file at ["http://github.com/tthibo/SQL-Tutorial/raw/master/candidates.txt":http://github.com/tthibo/SQL-Tutorial/raw/master/candidates.txt] and import
it using the Import icon (!http://github.com/tthibo/SQL-Tutorial/raw/master/import_icon.png!) as we did in Part I. 

* Remember to check the "First row contains column names" check box.
* And set the "Fields separated by" value to "Pipe (|)."

The import should add 17 rows to your *candidates* table:
!http://github.com/tthibo/SQL-Tutorial/raw/master/browse_candidates.png!

So now, rather than having candidate data included with each row of the contributor data, we have one row for each candidate. It's a much cleaner data structure.

h3. Referentially speaking: Associating tables using Foreign Keys

So, now we have the candidates table, but we also have a problem. The contributors data we used in Part I doesn't give us any way to link contributors to their candidates. We have no way of running queries that give, for example, total contributions per candidate. To create this reference between the two tables, we'll need a common field that the two tables share. The standard way of setting up this relationship is to include the *Primary Key* from the *referenced* table as a field in the *referencing* table. The new column in the referencing table is known as a [*Foreign Key*:http://en.wikipedia.org/wiki/Foreign_key].

Simply creating this foreign key column in the referencing table would be enough let us run queries across both tables, but SQL also allows us to explicitly declare the foreign key and thus enforce this reference at the database level.

So, let's create a new *contributors* table, but in addition to the data about the contributor, let's add a *candidate_id* field and let SQLite know that it is a foreign key referencing the *id* column in the *candidates* table:
<pre><code>CREATE TABLE "contributors" (
	"id" INTEGER PRIMARY KEY  AUTOINCREMENT  NOT NULL, 
	"last_name" VARCHAR, 
	"first_name" VARCHAR, 
	"middle_name" VARCHAR, 
	"street_1" VARCHAR, 
	"street_2" VARCHAR, 
	"city" VARCHAR, 
	"state" VARCHAR, 
	"zip" VARCHAR, 
	"amount" INTEGER, 
	"date" DATETIME, 
	"candidate_id" INTEGER NOT NULL,
	FOREIGN KEY(candidate_id) REFERENCES candidates(id)
	)</code></pre>
	
Notice the last two lines of that <code>CREATE</code> statement. The penultimate line adds the *candidate_id* column, defines it as an integer, and makes it a required field (it cannot be null). The final line defines *candidate_id* as a foreign key referencing the *id* column in the *candidates* table.

Now SQLite will enforce this reference, and if we try to enter a row in the *contributors* table using a *candidate_id* that doesn't actually appear in the *candidates* table, we'll get an error. In other words, every contributor must now have a candidate, and that candidate must already exist in the *candidates* table.

h3. JOIN

h3. OUTER JOIN

h3. self joins

h3. UNION

h3. CREATE INDEX

h3. SELECT INTO

h3. ALTER

h3. DROP

h3. Further Resources:
http://www.dbbm.fiocruz.br/class/Lecture/d17/sql/jhoffman/sqltut.html
http://zetcode.com/databases/sqlitetutorial/
http://www.sqlite.org/lang.html
http://www.sqlite.org/lang_keywords.html
http://www.sqlite.org/lang_expr.html
http://en.wikipedia.org/wiki/SQL
